//
//  Sequence_test.cpp
//
//  Created by Soso Limited on 10/26/15.
//
//

#include "catch.hpp"
#include "choreograph/Choreograph.h"

using namespace choreograph;
using namespace std;

TEST_CASE( "Sequences" )
{
  auto sequence = Sequence<float>( 0.0f )
    .then<RampTo>( 1.0f, 1.0f )
    .then<RampTo>( 10.0f, 1.0f )
    .then<RampTo>( 100.0f, 1.0f );

  SECTION( "Sequence duration is the sum of all of its component phrase's durations." )
  {
    REQUIRE( sequence.getDuration() == 3 );
  }

  SECTION( "Sequences have multiple construction patterns." )
  {
    SECTION( "Copy Constructor" )
    {
      Sequence<float> other( sequence );

      REQUIRE( other.getDuration() == sequence.getDuration() );
      REQUIRE( other.getValue( 1.5 ) == sequence.getValue( 1.5 ) );
    }

    SECTION( "Phrase Constructor" )
    {
      // Bug in VS2013 makes the single ref convertible to a vector ref.
      // Casting to base type avoids that incorrect conversion.
      auto ramp = PhraseRef<float>( makeRamp( 1.0f, 10.0f, 1.0f ) );
      Sequence<float> other( ramp );

      REQUIRE( other.getValue( 0.5 ) == ramp->getValue( 0.5 ) );
      REQUIRE( other.getDuration() == ramp->getDuration() );
    }
  }

  SECTION( "Sequence values within duration are interpolated by the appropriate Phrase." )
  {
    REQUIRE( sequence.getValue( 0.5 ) == 0.5 );
    REQUIRE( sequence.getValue( 1.0 ) == 1.0 );
    REQUIRE( sequence.getValue( 1.5 ) == 5.5 );
  }

  SECTION( "Sequence values outside duration are clamped to begin and end values." )
  {
    REQUIRE( sequence.getValue( - std::numeric_limits<float>::max() ) == sequence.getStartValue() );
    REQUIRE( sequence.getValue( std::numeric_limits<float>::max() ) == sequence.getEndValue() );
  }

  SECTION( "Looped sequence values are equivalent." )
  {
    Time offset = 1.55;
    // Since the precision of floats decreases as they get larger,
    // we need an epsilon larger than the delta from 1.0 to the next float.
    const Time epsilon = 1.0e-5;

    REQUIRE( (wrapTime( 10 * sequence.getDuration() + offset, sequence.getDuration() ) - offset) < epsilon );
    REQUIRE( (sequence.getValueWrapped( sequence.getDuration() + offset ) - sequence.getValue( offset ) ) < epsilon );
    REQUIRE( (sequence.getValueWrapped( (2 * sequence.getDuration()) + offset ) - sequence.getValue( offset ) ) < epsilon );
    REQUIRE( (sequence.getValueWrapped( (20 * sequence.getDuration()) + offset ) - sequence.getValue( offset ) ) < epsilon );
  }

  SECTION( "Sequences are composable." )
  {
    // The code generated by VS2013 differs a bit from Clang, so
    // we explicitly create the sequence phrase first to guarantee what kind of sequence we get.
    auto phrase = sequence.asPhrase();
    sequence.then( sequence ).then( phrase );

    // We have the sequence three times.
    REQUIRE( sequence.getDuration() == 9.0f );
    REQUIRE( sequence.getValue( 3.5f ) == sequence.getValue( 6.5f ) );
    REQUIRE( sequence.getValue( 1.0f ) == sequence.getValue( 4.0f ) );
  }

  SECTION( "Phrases can be spliced into sequences." )
  {
    REQUIRE( sequence.size() == 3 );
    sequence.splice( 1, 1, {} ); // 0-1, 10-100
    REQUIRE( sequence.size() == 2 );

    auto phrase = makeRamp( 10.0f, 50.0f, 1.0 );
    auto another = makeReverse<float>( phrase );
    sequence.splice( 1, 0, { phrase, another } ); // 0-1, 10-50, 50-10, 10-100
    REQUIRE( sequence.size() == 4 );
    REQUIRE( sequence.getDuration() == 4.0 );
    REQUIRE( sequence.getValue( 2.0 ) == 50.0f );

    phrase->setEndValue( 500.0f );
    REQUIRE( sequence.getValue( 2.0 ) == 500.0f );
    REQUIRE( sequence.getPhraseAtTime( 1.8 ) == phrase );
    REQUIRE( sequence.getPhraseAtIndex( 2 ) == another );

    sequence.replacePhraseAtIndex( 2, sequence.getPhraseAtIndex( 1 ) );
    REQUIRE( sequence.size() == 4 );
    REQUIRE( sequence.getPhraseAtIndex( 1 ) == sequence.getPhraseAtIndex( 2 ) );
  }

  SECTION( "Sequences prevent incorrect splicing." )
  {
    sequence.splice( 100, 100, {} );
    REQUIRE( sequence.size() == 3 );

    sequence.splice( 0, 100, {} );
    REQUIRE( sequence.size() == 0 );
  }
}

TEST_CASE( "Slicing Time" )
{
  SECTION( "Clip Phrases retime existing phrases and clamp their end values." )
  {
    auto ramp = makeRamp( 1.0f, 10.0f, 1.0f );
    auto clip_equal = ClipPhrase<float>( ramp, 0.0f, 1.0f );
    auto clip_from_start = ClipPhrase<float>( ramp, 0.0f, 0.5f );
    auto clip_middle = ClipPhrase<float>( ramp, 0.25f, 0.75f );
    auto clip_past_end = ClipPhrase<float>( ramp, 0.5f, 1.25f );

    REQUIRE( clip_equal.getDuration() == 1.0f );
    REQUIRE( clip_equal.getStartValue() == ramp->getStartValue() );
    REQUIRE( clip_equal.getEndValue() == ramp->getEndValue() );
    REQUIRE( clip_equal.getValue( 0.5f ) == ramp->getValue( 0.5f ) );

    REQUIRE( clip_from_start.getDuration() == 0.5f );
    REQUIRE( clip_from_start.getValue( 0.0f ) == ramp->getValue( 0.0f ) );
    REQUIRE( clip_from_start.getValue( 10.0f ) == ramp->getValue( 0.5f ) );

    REQUIRE( clip_middle.getDuration() == 0.5f );
    REQUIRE( clip_middle.getValue( 0.0f ) == ramp->getValue( 0.25f ) );
    REQUIRE( clip_middle.getEndValue() == ramp->getValue( 0.75f ) );

    REQUIRE( clip_past_end.getDuration() == 0.75f );
    REQUIRE( clip_past_end.getEndValue() == ramp->getEndValue() );
    REQUIRE( clip_past_end.getValue( 0.5f ) == ramp->getValue( 1.0f ) );
  }

  Output<float> target = 0.0f;
  auto sequence = Sequence<float>( 0.0f )
    .then<RampTo>( 1.0f, 1.0f )
    .then<RampTo>( 10.0f, 1.0f )
    .then<RampTo>( 100.0f, 1.0f );

  SECTION( "Sequences can be sliced into subsequences." )
  {
    auto slice_equal = sequence.slice( 0.0f, sequence.calcDuration() );
    auto slice_middle = sequence.slice( 0.25f, 2.25f );
    auto slice_past_end = sequence.slice( 0.5f, 3.5f );

    REQUIRE( slice_equal.getDuration() == sequence.getDuration() );
    REQUIRE( slice_equal.getValue( 1.5f ) == sequence.getValue( 1.5f ) );

    REQUIRE( sequence.getDuration() == 3 );
    REQUIRE( slice_middle.getDuration() == 2 );
    REQUIRE( slice_middle.getValue( 0.0f ) == sequence.getValue( 0.25f ) );
    REQUIRE( slice_middle.getEndValue() == sequence.getValue( 2.25f ) );

    REQUIRE( slice_past_end.getDuration() == 3 );
    REQUIRE( slice_past_end.getValue( 3.0f ) == sequence.getEndValue() );
    REQUIRE( slice_past_end.getValue( 0.0f ) == sequence.getValue( 0.5f ) );
  }


  SECTION( "Motions can slice their Sequence." )
  {
    Motion<float> motion( &target, sequence );

    SECTION( "Slicing changes the Sequence animation." )
    {
      motion.sliceSequence( 0.5f, 1.5f );

      motion.jumpTo( 1.0f );
      float v1 = target();

      motion.jumpTo( 0.0f );
      float v2 = target();

      REQUIRE( motion.getDuration() == 1 );
      REQUIRE( v1 == sequence.getValue( 1.5f ) );
      REQUIRE( v2 == sequence.getValue( 0.5f ) );
    }

    SECTION( "When sliced, the Motion's time is adjusted to be fixed relative to its Sequence." )
    {
      motion.jumpTo( 1.0f );
      motion.sliceSequence( 0.5f, 1.5f );

      REQUIRE( motion.time() == 0.5f );
    }

    SECTION( "Cutting before removes past Phrases from the Sequence." )
    {
      motion.jumpTo( 1.5f );
      float v1 = target();

      motion.cutPhrasesBefore( motion.time() );

      motion.jumpTo( 0.0f );
      float v2 = target();

      REQUIRE( v1 == v2 );
      REQUIRE( v1 == 5.5f );
      REQUIRE( motion.getDuration() == 1.5f );
    }

    SECTION( "Cut In slices the Sequence so it ends in the specified amount of time." )
    {
      motion.cutIn( 2.0f );
      REQUIRE( motion.getDuration() == 2 );
    }

    SECTION( "Cut In also removes Phrases prior to the current Motion time." )
    {
      motion.jumpTo( 1.0f );
      motion.cutIn( 2.0f );

      REQUIRE( motion.time() == 0 );
      REQUIRE( motion.getDuration() == 2 );
    }

    SECTION( "Cut In will extend the Sequence if the cut time is past the end of the Sequence." )
    {
      motion.jumpTo( 2.5f );
      motion.cutIn( 2.0f );

      motion.jumpTo( 1.5f );
      auto v1 = target();

      REQUIRE( v1 == sequence.getEndValue() );
      REQUIRE( motion.getDuration() == 2 );
    }
  }

  SECTION( "Timeline MotionOptions expose trim methods." )
  {
    Timeline timeline;
    auto options = timeline.apply( &target, sequence );

    SECTION( "With single Motion, Timeline duration is motions duration." )
    {
      REQUIRE( timeline.timeUntilFinish() == sequence.getDuration() );
    }

    SECTION( "Cut at trims the sequence relative to their start." )
    {
      options.cutAt( 2.0f );
      REQUIRE( timeline.timeUntilFinish() == 2.0f );
    }

    SECTION( "Cut In trims the sequence relative to the motion's current time." )
    {
      timeline.step( 0.5f );
      float v1 = target();
      options.cutIn( 0.5f );
      timeline.step( 0.0f );
      float v2 = target();

      REQUIRE( timeline.timeUntilFinish() == 0.5f );
      REQUIRE( v1 == v2 );
    }
  }
}
